#encoding: utf-8
import os
import csv
import numpy as np
import matplotlib.pyplot as plt

from sho import make, algo, iters, plot, num, bit, pb

nb_runs = 10

def ert(nb_runs, nb_sensors, sensor_range, domain_width, iters, solver, target, steady_delta, variation_scale, treshold) :
    """
    This function defines lists along the x and y axis useful for computing ERT. Those lists are field up through the different runs
    """
    probabilities = []
    calls_list = []
    for current_run in range(nb_runs) :
    	# This part execute snp.py module
    	os.system("python3 snp.py --nb-sensors " + nb_sensors + " --sensor-range " + sensor_range + " --domain-width " + domain_width + " --iters " + iters +  " --solver " + solver + " --target " + target + " --steady-delta " + steady_delta + " --variation-scale " + variation_scale + " --ert True")
    	
    	# Read the file generated by snp.py. We only consider the first two columns.
     	fichier = []
    	fichier_csv = csv.reader(open(solver + ".csv"), delimiter = ';')
    	for row in fichier_csv :
    		if len(row) == 3 :
    			fichier.append([float(row[0]),float(row[1])])
    	fichier = np.array(fichier)

    	# Check if the result of this run is above the treshold
    	index_one_run = 0
    	calls_one_run = []
    	for i in range(len(fichier)) :
    		if solver == "bit_evolution" or solver == "num_evolution" or solver == "bit_simple_evolution" or solver == "num_simple_evolution" :
    			calls_one_run.append(np.multiply(fichier[i][0],10))
    		else :
    			calls_one_run.append(fichier[i][0])
    		if fichier[i][1] >= treshold and index_one_run == 0 :
    			index_one_run = i
    			
    	# Add statistics of current run to plot the ERT
    	if probabilities == [] :
    		calls_list = calls_one_run
    		if index_one_run > 0 :
    			probabilities = [0 for _ in range(index_one_run)] + [1/nb_runs for _ in range(index_one_run,len(calls_one_run))]
    		else :
    			probabilities = [0 for _ in range(len(calls_one_run))]
    	else :
    		for i in range(len(calls_one_run)) :
    			calls_one_run[i] = calls_one_run[i] + calls_list[-1]
    		calls_list =  calls_list + calls_one_run
    		if index_one_run > 0 :
    			probabilities  = probabilities + [probabilities[-1] for _ in range(index_one_run)] + [probabilities[-1] + 1/nb_runs for _ in range(index_one_run,len(calls_one_run))]
    		else :
    			probabilities  = probabilities + [probabilities[-1] for _ in range(len(calls_one_run))]
    	
    return probabilities, calls_list

if __name__ == "__main__" :
    import argparse

    can = argparse.ArgumentParser()
    
    can.add_argument("-n", "--nb-sensors", metavar="NB", default=3, type=int,
            help="Number of sensors")

    can.add_argument("-r", "--sensor-range", metavar="RATIO", default=0.3, type=float,
            help="Sensors' range (as a fraction of domain width, max is âˆš2)")

    can.add_argument("-w", "--domain-width", metavar="NB", default=30, type=int,
            help="Domain width (a number of cells)")

    can.add_argument("-i", "--iters", metavar="NB", default=100, type=int,
            help="Maximum number of iterations")
    
    can.add_argument("-t", "--target", metavar="VAL", default=30*30, type=float,
            help="Objective function value target")

    can.add_argument("-y", "--steady-delta", metavar="NB", default=50, type=float,
            help="Stop if no improvement after NB iterations")

    can.add_argument("-a", "--variation-scale", metavar="RATIO", default=0.3, type=float,
            help="Scale of the variation operators (as a ration of the domain width)")
    
    tresholds = [650,662,670]
    
    the = can.parse_args()
    
    count_treshold = 1
    plt.figure(1)
    for treshold in tresholds :
    	probabilities1, calls_list1 = ert(nb_runs, str(the.nb_sensors), str(the.sensor_range), str(the.domain_width), str(the.iters), "num_greedy", str(the.target), str(the.steady_delta), str(the.variation_scale), treshold)
    	probabilities2, calls_list2 = ert(nb_runs, str(the.nb_sensors), str(the.sensor_range), str(the.domain_width), str(the.iters), "num_annealing", str(the.target), str(the.steady_delta), str(the.variation_scale), treshold)

    	plt.subplot(2,2,count_treshold)
    	plt.xlim(right=max(calls_list1[-1],calls_list2[-2]))
    	plt.xlabel("Number of calls to objective function")
    	plt.ylim(-0.1,1.1)
    	plt.ylabel("Probability")
    	plt.title("Expected Run Time Empirical Cumulative Density Function for a treshold = " + str(treshold))
    	plt.plot(calls_list1,probabilities1, label="Greedy algorithm")
    	plt.plot(calls_list2,probabilities2, label="Numeric simulated annealing")
    	plt.legend(loc="upper left")

    	count_treshold += 1

    treshold = 665
    probabilities0, calls_list0 = ert(nb_runs, str(the.nb_sensors), str(the.sensor_range), str(the.domain_width), str(the.iters), "num_simple_evolution", str(the.target), str(the.steady_delta), str(the.variation_scale), treshold)

    plt.figure(2)
    plt.plot(calls_list0, probabilities0, label="Evolutionary algorithm")
    plt.xlim(right=calls_list0[-1])
    plt.xlabel("Number of calls to objective function")
    plt.ylim(-0.1,1.1)
    plt.ylabel("Probability")
    plt.title("Expected Run Time Empirical Cumulative Density Function for a treshold = " + str(treshold))
    plt.legend(loc="upper left")

    plt.show()